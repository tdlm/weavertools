# Weaver Tools - Cursor Rules

## Project Overview
Weaver Tools is a Next.js 14 application providing developer utility tools including Base64 encoding/decoding, JSON formatting, URL query string comparison, and URL parsing.

## Code Style Guidelines

### TypeScript
- Use strict TypeScript with proper typing
- Always use strict equality checks (`===` and `!==`)
- Prefer early returns over deep nesting
- Use functional components with React hooks
- Define proper types/interfaces for all data structures

### React/Next.js
- Use Next.js 14 App Router conventions
- Client components must have `"use client"` directive
- Use server actions for data fetching when appropriate
- Leverage `nuqs` for URL-based state management when state should be shareable
- Prefer functional components over class components

### Styling
- Use Tailwind CSS utility classes
- Follow existing design patterns (gray-900 sidebar, white content area)
- Use responsive design (mobile-first approach)
- Maintain consistent spacing and typography
- Use sticky positioning for tool input sections

### Component Structure
- Page components in `app/tools/[tool-name]/page.tsx`
- Page-specific logic in `components/pages/[tool-name].tsx`
- Reusable UI components in `components/ui/`
- Shared components in `components/`
- Utility functions in `lib/`
- Server actions in `actions/`

### State Management
- Use `nuqs` for state that should be in URL (shareable/bookmarkable)
- Use React `useState` for local component state
- Use `useEffect` for side effects and derived state

### Error Handling
- Always handle errors gracefully
- Display user-friendly error messages
- Use try-catch blocks for async operations
- Validate inputs before processing

### URL Handling
- Validate URLs before processing using `isValidUrl()` utility
- Show visual feedback (red border) for invalid URLs
- Use `splitUrl()` and `splitQueryString()` utilities for URL parsing
- Encode/decode URL state appropriately when using `nuqs`

### Code Organization
- Keep components focused and single-purpose
- Extract reusable logic into utility functions
- Use descriptive variable and function names
- Add JSDoc comments for complex functions
- Follow existing file naming conventions (kebab-case for files)

### UI/UX Patterns
- Use `TitleHeader` component for page titles
- Use `UrlInput` component for URL inputs
- Use `DataList` for displaying key-value pairs
- Use `DiffList` for showing differences
- Show loading states during async operations
- Provide empty states when no data is available
- Include copy-to-clipboard functionality where appropriate

### Dependencies
- Use existing dependencies when possible
- Follow existing patterns for new dependencies
- Keep dependencies up to date
- Document any new major dependencies

### Testing Considerations
- Write testable code with pure functions where possible
- Keep components focused and testable
- Consider edge cases (empty inputs, invalid data, network errors)

## Common Patterns

### Adding a New Tool
1. Create route: `app/tools/[tool-name]/page.tsx`
2. Create component: `components/pages/[tool-name].tsx`
3. Add to navigation in `components/base-layout.tsx`
4. Add utility functions to `lib/` if needed
5. Follow existing tool patterns for consistency

### URL State Management
```typescript
const [value, setValue] = useQueryState("key", {
  parse: (value) => decodeURIComponent(value),
  serialize: (value) => encodeURIComponent(value),
});
```

### Error Display
```typescript
{error && (
  <div className="bg-red-50 border border-red-200 rounded-md p-3">
    <p className="text-red-800 text-sm">{error}</p>
  </div>
)}
```

### Loading States
```typescript
{isLoading ? <Loader className="animate-spin" /> : "Action"}
```

## Best Practices
- Always validate user input
- Provide immediate feedback for user actions
- Use semantic HTML elements
- Ensure accessibility (proper labels, ARIA attributes)
- Optimize for performance (avoid unnecessary re-renders)
- Keep bundle size in mind when adding dependencies
- Follow Next.js best practices for SEO and performance

